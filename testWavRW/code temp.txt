



// ++++++++++++++++++  dsd2pcm 原有的
	//vector<unsigned char> dsd_data(block * channels);		// 这个是每一帧的,帧长为block * channels 

	//vector<unsigned char> pcm_data(block * channels * bytespersample);	// 用于导出 PCM
	//char * const dsd_in = reinterpret_cast<char*>(&dsd_data[0]);
	//char * const pcm_out = reinterpret_cast<char*>(&pcm_data[0]);



			//unsigned char * out = &pcm_data[0] + c * bytespersample;

			//if (bits == 16) {
			//	for (int s = 0; s<block; ++s) {
			//		float r = float_data[s] * 32768 + ns[c].get();
			//		long smp = clip(-32768, myround(r), 32767);
			//		ns[c].update(clip(-1, smp - r, 1));

			//		//write_intel16(out, smp);
			//		write_intel16( (unsigned char*)&pOut_s16 + n + s, smp);

			//		//out += channels * bytespersample;
			//	}
			//}
			//else {
			//	for (int s = 0; s<block; ++s) {
			//		float r = float_data[s] * 8388608;
			//		long smp = clip(-8388608, myround(r), 8388607);

			//		//write_intel24(out, smp);

			//		//out += channels * bytespersample;
			//	}
			//}


// ========== 这些是原先的测试 ==========//
//uint8_t *ch1 = new uint8_t[nSamples / 2]{ 0 };
//uint8_t *ch2 = new uint8_t[nSamples / 2]{ 0 };

//cout << dsdfile.channel_num << endl;
//cout << dsdfile.block_per_channel << endl;

//for (size_t i = 0; i < nSamples / 2 / 4096; i++)	// chn = 2, 4096 is block size
//{
//	ch1[i] = pSampleData[i * 2 * 4096];
//	ch2[i] = pSampleData[i * 2 * 4096 + 1];

//}
// 抽取 
//for (size_t n = 0; n < samples_per_ch; n++)
//{
//	pOut_882_u8[n] = ch1[ n * nStep];
//}

//float *pOut_882 = new float[samples_per_ch] {};

// FIR   转化，从 DSD 到 PCM  待补充





















//FILE *fp = NULL;
//fopen_s(&fp, "dukou_noReverb.wav","rb");
//assert(fp != NULL);
//Header header;

//fread(&header, sizeof(header), 1, fp);
//fseek(fp, sizeof(header), 0);

//short data[10];
//fread(data, 10 * sizeof(short), 1,fp);

//for (size_t i = 0; i < 10; i++)
//{
//	cout << data[i] << endl;
//}
//cout << header.sample_rate;

//fclose(fp);
//typedef struct Header {
//struct Header {
//	/* WAV-header parameters				Memory address - Occupied space - Describes */
//	char chunk_ID[4];                           // 0x00 4 byte - RIFF string
//	uint32_t  chunk_size;                  // 0x04 4 byte - overall size of
//	char format[4];                             // 0x08 4 byte - WAVE string
//	char fmt_chunk_marker[4];                   // 0x0c 4 byte - fmt string with trailing null char
//	uint32_t length_of_fmt;					  // 0x10 4 byte - length of the format data,the next part
//	uint16_t  format_type;					// 0x14 2 byte - format type. 1-PCM, 3- IEEE float, 6 - 8bit A law, 7 - 8bit mu law
//	uint16_t  channels;						 // 0x16 2 byte - nunbers of channels
//	uint32_t  sample_rate;					// 0x18 4 byte - sampling rate (blocks per second)
//	uint32_t  byte_rate;                   // 0x1c 4 byte - SampleRate * NumChannels * BitsPerSample/8 [比特率]
//	uint16_t  block_align;                 // 0x20 2 byte - NumChannels * BitsPerSample/8 [块对齐=通道数*每次采样得到的样本位数/8]
//	uint16_t  bits_per_sample;				 // 0x22 2 byte - bits per sample, 8- 8bits, 16- 16 bits etc [位宽]
//	char data_chunk_header[4];				// 0x24 4 byte - DATA string or FLLR string
//	uint32_t  data_size;					 // 0x28 4 byte - NumSamples * NumChannels * BitsPerSample/8 - size of the next chunk 
//											 //				that will be read,that is the size of PCM data.
//};